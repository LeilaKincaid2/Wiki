---
title: Map Data
---
# Map Data
* [Intro](#intro)
* [Data Format](#data-format)
* [Checksum](#checksum)

## Intro

All Rust maps (apart from FacePunch created), are stored in a .map file.

When first joining a server that is running a ProcGen map, Rust will generate the map from the:

### Size (1000-6000)

### Seed (0-9999999999)

### MapType (ProcGen/Barren)

The map is then saved into a .map file, and can be found in the Rust install directory inside the maps folder. The map filename 
will be named MapType.Size.Seed.map





## Data Format

## Checksum
When a Rust Server loads a map, it creates a checksum from the map file. This checksum is generated by the heightmap and the prefabs data.

It is therefore possible to have 2 separate map files running, one on the client and one on the server, as long as the heightmap and prefab data is the same.

Most topology layers are only used by the server to generate entities on the map, therefore they can be wiped on the clients version of the map without any issues.

This can also be used to bypass entity spawning restrictions on the Ground and Biome data. The client can be shown the intended Ground splat with the corresponding Biome tint, whilst the server can have a different Ground splat to help it spawn in a certain entity.

Biome temperatures are handled server side, so it is possible to have a desert visually but with the temperature of an Arctic Biome.

This is the snippet of code responsible for generating the Checksum.

``` csharp
public string Hash()
    {
        var checksum = new Checksum();

        var heights = GetMap("terrain"); // World Heightmap
        if (heights != null)
        {
            for (int i = 0; i < heights.data.Length; i++)
            {
                checksum.Add(heights.data[i]);
            }
        }

        var prefabs = world.prefabs;
        if (prefabs != null)
        {
            for (int i = 0; i < prefabs.Count; i++)
            {
                var prefab = prefabs[i];

                checksum.Add(prefab.id);

                // Include the 3 most significant bytes as an approximation
                checksum.Add(prefab.position.x, 3);
                checksum.Add(prefab.position.y, 3);
                checksum.Add(prefab.position.z, 3);
                checksum.Add(prefab.scale.x, 3);
                checksum.Add(prefab.scale.y, 3);
                checksum.Add(prefab.scale.z, 3);
            }
        }
        return checksum.MD5();
    }
```
