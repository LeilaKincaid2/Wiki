---
title: Map Data
---
# Map Data
* [Intro](#intro)
* [Data Format](#data-format)
* [Checksum](#checksum)

## Intro

All Rust maps (apart from FacePunch created), are stored in a .map file.

When first joining a server that is running a ProcGen map, Rust will generate the map from the:

### Size (1000-6000)

### Seed (0-9999999999)

### MapType (ProcGen/Barren)

The map is then saved into a .map file, and can be found in the Rust install directory inside the maps folder. The map filename 
will be named MapType.Size.Seed.map





## Data Format

Map files are stored in the format below, and compressed using a LZ4Stream.

They first contain the World Serialization number, currently 9 and then the WorldData.

``` csharp
public class WorldData
	{
		[ProtoMember(1)] public uint size = 4000; // The size of the Terrain, in Unity metres.
		[ProtoMember(2)] public List<MapData> maps = new List<MapData>();
		[ProtoMember(3)] public List<PrefabData> prefabs = new List<PrefabData>();
		[ProtoMember(4)] public List<PathData> paths = new List<PathData>();
	}
```

The MapData contains a layer (Ground, Biome, Heightmap etc) and the corresponding ByteMap.

It is stored in the following format:

``` csharp
public class MapData
	{
		[ProtoMember(1)] public string name;
		[ProtoMember(2)] public byte[] data;
	}
```

The PrefabData contains info on the ID of the prefab, and it's world space values.

It is stored in the following format:

``` csharp
public class PrefabData
	{
		[ProtoMember(1)] public string category; // Decor, Monument etc
		[ProtoMember(2)] public uint id; // PrefabID
		[ProtoMember(3)] public VectorData position; // Vector3 of the position in world space.
		[ProtoMember(4)] public VectorData rotation; // Vector3 of the rotation in world space.
		[ProtoMember(5)] public VectorData scale; // Vector3 of the scale in world space.
	}
```

The PathData contains info on the Rivers and Roads of the map.

It is stored in the following format:

``` csharp
public class PathData
	{
		[ProtoMember(1)] public string name; 
		[ProtoMember(2)] public bool spline;
		[ProtoMember(3)] public bool start;
		[ProtoMember(4)] public bool end;
		[ProtoMember(5)] public float width;
		[ProtoMember(6)] public float innerPadding;
		[ProtoMember(7)] public float outerPadding;
		[ProtoMember(8)] public float innerFade;
		[ProtoMember(9)] public float outerFade;
		[ProtoMember(10)] public float randomScale;
		[ProtoMember(11)] public float meshOffset;
		[ProtoMember(12)] public float terrainOffset;
		[ProtoMember(13)] public int splat;
		[ProtoMember(14)] public int topology;
		[ProtoMember(15)] public VectorData[] nodes; // List of the world spaces of the individual nodes.
	}
```


## Checksum
When a Rust Server loads a map, it creates a checksum from the map file. This checksum is generated by the heightmap and the prefabs data.

It is therefore possible to have 2 separate map files running, one on the client and one on the server, as long as the heightmap and prefab data is the same.

Most topology layers are only used by the server to generate entities on the map, therefore they can be wiped on the clients version of the map without any issues.

This can also be used to bypass entity spawning restrictions on the Ground and Biome data. The client can be shown the intended Ground splat with the corresponding Biome tint, whilst the server can have a different Ground splat to help it spawn in a certain entity.

Biome temperatures are handled server side, so it is possible to have a desert visually but with the temperature of an Arctic Biome.

This is the snippet of code responsible for generating the Checksum.

``` csharp
public string Hash()
    {
        var checksum = new Checksum();

        var heights = GetMap("terrain"); // World Heightmap
        if (heights != null)
        {
            for (int i = 0; i < heights.data.Length; i++)
            {
                checksum.Add(heights.data[i]);
            }
        }

        var prefabs = world.prefabs;
        if (prefabs != null)
        {
            for (int i = 0; i < prefabs.Count; i++)
            {
                var prefab = prefabs[i];

                checksum.Add(prefab.id);

                // Include the 3 most significant bytes as an approximation
                checksum.Add(prefab.position.x, 3);
                checksum.Add(prefab.position.y, 3);
                checksum.Add(prefab.position.z, 3);
                checksum.Add(prefab.scale.x, 3);
                checksum.Add(prefab.scale.y, 3);
                checksum.Add(prefab.scale.z, 3);
            }
        }
        return checksum.MD5();
    }
```
